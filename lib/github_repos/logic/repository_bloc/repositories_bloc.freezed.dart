// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'repositories_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RepositoriesEventTearOff {
  const _$RepositoriesEventTearOff();

  _refreshRepositories refreshRepositories() {
    return const _refreshRepositories();
  }

  _loadRepositories loadRepositories() {
    return const _loadRepositories();
  }

  _searchForRepository searchForRepository(String searchedPhrase) {
    return _searchForRepository(
      searchedPhrase,
    );
  }
}

/// @nodoc
const $RepositoriesEvent = _$RepositoriesEventTearOff();

/// @nodoc
mixin _$RepositoriesEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() refreshRepositories,
    required TResult Function() loadRepositories,
    required TResult Function(String searchedPhrase) searchForRepository,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_refreshRepositories value) refreshRepositories,
    required TResult Function(_loadRepositories value) loadRepositories,
    required TResult Function(_searchForRepository value) searchForRepository,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RepositoriesEventCopyWith<$Res> {
  factory $RepositoriesEventCopyWith(
          RepositoriesEvent value, $Res Function(RepositoriesEvent) then) =
      _$RepositoriesEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$RepositoriesEventCopyWithImpl<$Res>
    implements $RepositoriesEventCopyWith<$Res> {
  _$RepositoriesEventCopyWithImpl(this._value, this._then);

  final RepositoriesEvent _value;
  // ignore: unused_field
  final $Res Function(RepositoriesEvent) _then;
}

/// @nodoc
abstract class _$refreshRepositoriesCopyWith<$Res> {
  factory _$refreshRepositoriesCopyWith(_refreshRepositories value,
          $Res Function(_refreshRepositories) then) =
      __$refreshRepositoriesCopyWithImpl<$Res>;
}

/// @nodoc
class __$refreshRepositoriesCopyWithImpl<$Res>
    extends _$RepositoriesEventCopyWithImpl<$Res>
    implements _$refreshRepositoriesCopyWith<$Res> {
  __$refreshRepositoriesCopyWithImpl(
      _refreshRepositories _value, $Res Function(_refreshRepositories) _then)
      : super(_value, (v) => _then(v as _refreshRepositories));

  @override
  _refreshRepositories get _value => super._value as _refreshRepositories;
}

/// @nodoc

class _$_refreshRepositories implements _refreshRepositories {
  const _$_refreshRepositories();

  @override
  String toString() {
    return 'RepositoriesEvent.refreshRepositories()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _refreshRepositories);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() refreshRepositories,
    required TResult Function() loadRepositories,
    required TResult Function(String searchedPhrase) searchForRepository,
  }) {
    return refreshRepositories();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
  }) {
    return refreshRepositories?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
    required TResult orElse(),
  }) {
    if (refreshRepositories != null) {
      return refreshRepositories();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_refreshRepositories value) refreshRepositories,
    required TResult Function(_loadRepositories value) loadRepositories,
    required TResult Function(_searchForRepository value) searchForRepository,
  }) {
    return refreshRepositories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
  }) {
    return refreshRepositories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
    required TResult orElse(),
  }) {
    if (refreshRepositories != null) {
      return refreshRepositories(this);
    }
    return orElse();
  }
}

abstract class _refreshRepositories implements RepositoriesEvent {
  const factory _refreshRepositories() = _$_refreshRepositories;
}

/// @nodoc
abstract class _$loadRepositoriesCopyWith<$Res> {
  factory _$loadRepositoriesCopyWith(
          _loadRepositories value, $Res Function(_loadRepositories) then) =
      __$loadRepositoriesCopyWithImpl<$Res>;
}

/// @nodoc
class __$loadRepositoriesCopyWithImpl<$Res>
    extends _$RepositoriesEventCopyWithImpl<$Res>
    implements _$loadRepositoriesCopyWith<$Res> {
  __$loadRepositoriesCopyWithImpl(
      _loadRepositories _value, $Res Function(_loadRepositories) _then)
      : super(_value, (v) => _then(v as _loadRepositories));

  @override
  _loadRepositories get _value => super._value as _loadRepositories;
}

/// @nodoc

class _$_loadRepositories implements _loadRepositories {
  const _$_loadRepositories();

  @override
  String toString() {
    return 'RepositoriesEvent.loadRepositories()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _loadRepositories);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() refreshRepositories,
    required TResult Function() loadRepositories,
    required TResult Function(String searchedPhrase) searchForRepository,
  }) {
    return loadRepositories();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
  }) {
    return loadRepositories?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
    required TResult orElse(),
  }) {
    if (loadRepositories != null) {
      return loadRepositories();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_refreshRepositories value) refreshRepositories,
    required TResult Function(_loadRepositories value) loadRepositories,
    required TResult Function(_searchForRepository value) searchForRepository,
  }) {
    return loadRepositories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
  }) {
    return loadRepositories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
    required TResult orElse(),
  }) {
    if (loadRepositories != null) {
      return loadRepositories(this);
    }
    return orElse();
  }
}

abstract class _loadRepositories implements RepositoriesEvent {
  const factory _loadRepositories() = _$_loadRepositories;
}

/// @nodoc
abstract class _$searchForRepositoryCopyWith<$Res> {
  factory _$searchForRepositoryCopyWith(_searchForRepository value,
          $Res Function(_searchForRepository) then) =
      __$searchForRepositoryCopyWithImpl<$Res>;
  $Res call({String searchedPhrase});
}

/// @nodoc
class __$searchForRepositoryCopyWithImpl<$Res>
    extends _$RepositoriesEventCopyWithImpl<$Res>
    implements _$searchForRepositoryCopyWith<$Res> {
  __$searchForRepositoryCopyWithImpl(
      _searchForRepository _value, $Res Function(_searchForRepository) _then)
      : super(_value, (v) => _then(v as _searchForRepository));

  @override
  _searchForRepository get _value => super._value as _searchForRepository;

  @override
  $Res call({
    Object? searchedPhrase = freezed,
  }) {
    return _then(_searchForRepository(
      searchedPhrase == freezed
          ? _value.searchedPhrase
          : searchedPhrase // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_searchForRepository implements _searchForRepository {
  const _$_searchForRepository(this.searchedPhrase);

  @override
  final String searchedPhrase;

  @override
  String toString() {
    return 'RepositoriesEvent.searchForRepository(searchedPhrase: $searchedPhrase)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _searchForRepository &&
            const DeepCollectionEquality()
                .equals(other.searchedPhrase, searchedPhrase));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(searchedPhrase));

  @JsonKey(ignore: true)
  @override
  _$searchForRepositoryCopyWith<_searchForRepository> get copyWith =>
      __$searchForRepositoryCopyWithImpl<_searchForRepository>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() refreshRepositories,
    required TResult Function() loadRepositories,
    required TResult Function(String searchedPhrase) searchForRepository,
  }) {
    return searchForRepository(searchedPhrase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
  }) {
    return searchForRepository?.call(searchedPhrase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? refreshRepositories,
    TResult Function()? loadRepositories,
    TResult Function(String searchedPhrase)? searchForRepository,
    required TResult orElse(),
  }) {
    if (searchForRepository != null) {
      return searchForRepository(searchedPhrase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_refreshRepositories value) refreshRepositories,
    required TResult Function(_loadRepositories value) loadRepositories,
    required TResult Function(_searchForRepository value) searchForRepository,
  }) {
    return searchForRepository(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
  }) {
    return searchForRepository?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_refreshRepositories value)? refreshRepositories,
    TResult Function(_loadRepositories value)? loadRepositories,
    TResult Function(_searchForRepository value)? searchForRepository,
    required TResult orElse(),
  }) {
    if (searchForRepository != null) {
      return searchForRepository(this);
    }
    return orElse();
  }
}

abstract class _searchForRepository implements RepositoriesEvent {
  const factory _searchForRepository(String searchedPhrase) =
      _$_searchForRepository;

  String get searchedPhrase;
  @JsonKey(ignore: true)
  _$searchForRepositoryCopyWith<_searchForRepository> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$RepositoriesStateTearOff {
  const _$RepositoriesStateTearOff();

  _RepositoriesLoading loading() {
    return const _RepositoriesLoading();
  }

  _RepositoriesContent content(
      List<Repository> listOfRepositories, String searchedPhrase) {
    return _RepositoriesContent(
      listOfRepositories,
      searchedPhrase,
    );
  }

  _RepositoriesError error() {
    return const _RepositoriesError();
  }
}

/// @nodoc
const $RepositoriesState = _$RepositoriesStateTearOff();

/// @nodoc
mixin _$RepositoriesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)
        content,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RepositoriesLoading value) loading,
    required TResult Function(_RepositoriesContent value) content,
    required TResult Function(_RepositoriesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RepositoriesStateCopyWith<$Res> {
  factory $RepositoriesStateCopyWith(
          RepositoriesState value, $Res Function(RepositoriesState) then) =
      _$RepositoriesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$RepositoriesStateCopyWithImpl<$Res>
    implements $RepositoriesStateCopyWith<$Res> {
  _$RepositoriesStateCopyWithImpl(this._value, this._then);

  final RepositoriesState _value;
  // ignore: unused_field
  final $Res Function(RepositoriesState) _then;
}

/// @nodoc
abstract class _$RepositoriesLoadingCopyWith<$Res> {
  factory _$RepositoriesLoadingCopyWith(_RepositoriesLoading value,
          $Res Function(_RepositoriesLoading) then) =
      __$RepositoriesLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$RepositoriesLoadingCopyWithImpl<$Res>
    extends _$RepositoriesStateCopyWithImpl<$Res>
    implements _$RepositoriesLoadingCopyWith<$Res> {
  __$RepositoriesLoadingCopyWithImpl(
      _RepositoriesLoading _value, $Res Function(_RepositoriesLoading) _then)
      : super(_value, (v) => _then(v as _RepositoriesLoading));

  @override
  _RepositoriesLoading get _value => super._value as _RepositoriesLoading;
}

/// @nodoc

class _$_RepositoriesLoading implements _RepositoriesLoading {
  const _$_RepositoriesLoading();

  @override
  String toString() {
    return 'RepositoriesState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _RepositoriesLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)
        content,
    required TResult Function() error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RepositoriesLoading value) loading,
    required TResult Function(_RepositoriesContent value) content,
    required TResult Function(_RepositoriesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _RepositoriesLoading implements RepositoriesState {
  const factory _RepositoriesLoading() = _$_RepositoriesLoading;
}

/// @nodoc
abstract class _$RepositoriesContentCopyWith<$Res> {
  factory _$RepositoriesContentCopyWith(_RepositoriesContent value,
          $Res Function(_RepositoriesContent) then) =
      __$RepositoriesContentCopyWithImpl<$Res>;
  $Res call({List<Repository> listOfRepositories, String searchedPhrase});
}

/// @nodoc
class __$RepositoriesContentCopyWithImpl<$Res>
    extends _$RepositoriesStateCopyWithImpl<$Res>
    implements _$RepositoriesContentCopyWith<$Res> {
  __$RepositoriesContentCopyWithImpl(
      _RepositoriesContent _value, $Res Function(_RepositoriesContent) _then)
      : super(_value, (v) => _then(v as _RepositoriesContent));

  @override
  _RepositoriesContent get _value => super._value as _RepositoriesContent;

  @override
  $Res call({
    Object? listOfRepositories = freezed,
    Object? searchedPhrase = freezed,
  }) {
    return _then(_RepositoriesContent(
      listOfRepositories == freezed
          ? _value.listOfRepositories
          : listOfRepositories // ignore: cast_nullable_to_non_nullable
              as List<Repository>,
      searchedPhrase == freezed
          ? _value.searchedPhrase
          : searchedPhrase // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_RepositoriesContent implements _RepositoriesContent {
  const _$_RepositoriesContent(this.listOfRepositories, this.searchedPhrase);

  @override
  final List<Repository> listOfRepositories;
  @override
  final String searchedPhrase;

  @override
  String toString() {
    return 'RepositoriesState.content(listOfRepositories: $listOfRepositories, searchedPhrase: $searchedPhrase)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RepositoriesContent &&
            const DeepCollectionEquality()
                .equals(other.listOfRepositories, listOfRepositories) &&
            const DeepCollectionEquality()
                .equals(other.searchedPhrase, searchedPhrase));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(listOfRepositories),
      const DeepCollectionEquality().hash(searchedPhrase));

  @JsonKey(ignore: true)
  @override
  _$RepositoriesContentCopyWith<_RepositoriesContent> get copyWith =>
      __$RepositoriesContentCopyWithImpl<_RepositoriesContent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)
        content,
    required TResult Function() error,
  }) {
    return content(listOfRepositories, searchedPhrase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
  }) {
    return content?.call(listOfRepositories, searchedPhrase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (content != null) {
      return content(listOfRepositories, searchedPhrase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RepositoriesLoading value) loading,
    required TResult Function(_RepositoriesContent value) content,
    required TResult Function(_RepositoriesError value) error,
  }) {
    return content(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
  }) {
    return content?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
    required TResult orElse(),
  }) {
    if (content != null) {
      return content(this);
    }
    return orElse();
  }
}

abstract class _RepositoriesContent implements RepositoriesState {
  const factory _RepositoriesContent(
          List<Repository> listOfRepositories, String searchedPhrase) =
      _$_RepositoriesContent;

  List<Repository> get listOfRepositories;
  String get searchedPhrase;
  @JsonKey(ignore: true)
  _$RepositoriesContentCopyWith<_RepositoriesContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RepositoriesErrorCopyWith<$Res> {
  factory _$RepositoriesErrorCopyWith(
          _RepositoriesError value, $Res Function(_RepositoriesError) then) =
      __$RepositoriesErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$RepositoriesErrorCopyWithImpl<$Res>
    extends _$RepositoriesStateCopyWithImpl<$Res>
    implements _$RepositoriesErrorCopyWith<$Res> {
  __$RepositoriesErrorCopyWithImpl(
      _RepositoriesError _value, $Res Function(_RepositoriesError) _then)
      : super(_value, (v) => _then(v as _RepositoriesError));

  @override
  _RepositoriesError get _value => super._value as _RepositoriesError;
}

/// @nodoc

class _$_RepositoriesError implements _RepositoriesError {
  const _$_RepositoriesError();

  @override
  String toString() {
    return 'RepositoriesState.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _RepositoriesError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)
        content,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<Repository> listOfRepositories, String searchedPhrase)?
        content,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RepositoriesLoading value) loading,
    required TResult Function(_RepositoriesContent value) content,
    required TResult Function(_RepositoriesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RepositoriesLoading value)? loading,
    TResult Function(_RepositoriesContent value)? content,
    TResult Function(_RepositoriesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _RepositoriesError implements RepositoriesState {
  const factory _RepositoriesError() = _$_RepositoriesError;
}
